///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2019 Oracle and/or its affiliates. All rights reserved.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= Metrics  MP Guide
:description: Helidon metrics s
:keywords: helidon, metrics, metrics, 

This document describes basic examples that use both built-in and custom metrics with Helidon MP.

== What you need

[width=50%,role="flex, sm7"]
|===
|About 30 minutes
|<<about/03_prerequisites.adoc,Helidon Prerequisites>>
|===

TIP: See the full Microprofile Metrics specification at https://github.com/eclipse/microprofile-metrics/releases/tag/1.1

=== Create a sample MP project

Generate the project sources using the Helidon MP Maven archetype.
The result is a simple project that can be used for the examples in this guide.

[source,bash,subs="attributes+"]
.Run the Maven archetype
----
mvn archetype:generate -DinteractiveMode=false \
    -DarchetypeGroupId=io.helidon.archetypes \
    -DarchetypeArtifactId=helidon-quickstart-mp \
    -DarchetypeVersion={helidon-version} \
    -DgroupId=io.helidon.examples \
    -DartifactId=helidon-quickstart-mp \
    -Dpackage=io.helidon.examples.quickstart.mp
----

=== Using the built-in metrics

Helidon provides 3 scopes of metrics data as shown below. The base and vendor metrics are automatically enabled in Helidon.
The /metrics endpoint will return data for all scopes.

1. /metrics/base - Base metrics data as specified by the MicroProfile Metrics specification
2. /metrics/vendor - Helidon specific metrics data
3. /metrics/application - Application specific metrics data


This example will demonstrate how to use the built-in metrics.  These examples are all executed
from the root directory of your project (helidon-quickstart-mp)

[source,bash]
.Build the application, skipping unit tests, then run it
----
mvn package -DskipTests=true
java -jar target/helidon-quickstart-mp.jar
----

NOTE: Metrics can be returned in either text format (the default), or JSON.  The text format uses OpenMetrics Text Format,
see https://prometheus.io/docs/instrumenting/exposition_formats/#text-format-details

[source,bash]
.Verify the metrics endpoint in a new terminal window
----
curl http://localhost:8080/metrics
----

[source,text]
.Text response.
----
# TYPE base:classloader_current_loaded_class_count counter
# HELP base:classloader_current_loaded_class_count Displays the number of classes that are currently loaded in the Java virtual machine.
base:classloader_current_loaded_class_count 7511
# TYPE base:classloader_total_loaded_class_count counter
# HELP base:classloader_total_loaded_class_count Displays the total number of classes that have been loaded since the Java virtual machine has started execution.
base:classloader_total_loaded_class_count 7512
...
----

Get the same data in JSON format.

[source,bash]
.Verify the metrics endpoint with an HTTP accept header
----
curl -H "Accept: application/json"  http://localhost:8080/metrics
----

[source,json]
.JSON response.
----
{
  "base": {
    "classloader.currentLoadedClass.count": 7534,
    "classloader.totalLoadedClass.count": 7538,
    "classloader.totalUnloadedClass.count": 1,
    "cpu.availableProcessors": 4,
    "cpu.systemLoadAverage": 2.83349609375,
    "gc.PS MarkSweep.count": 2,
    "gc.PS MarkSweep.time": 77,
    "gc.PS Scavenge.count": 5,
    "gc.PS Scavenge.time": 37,
    "jvm.uptime": 727588,
    "memory.committedHeap": 284164096,
    "memory.maxHeap": 3817865216,
    "memory.usedHeap": 53283088,
    "thread.count": 44,
    "thread.daemon.count": 35,
    "thread.max.count": 44
  },
  "vendor": {
    "grpc.requests.count": 0,
    "grpc.requests.meter": {
      "count": 0,
      "meanRate": 0.0,
      "oneMinRate": 0.0,
      "fiveMinRate": 0.0,
      "fifteenMinRate": 0.0
    },
    "requests.count": 6,
    "requests.meter": {
      "count": 6,
      "meanRate": 0.008275992296704147,
      "oneMinRate": 0.01576418632772332,
      "fiveMinRate": 0.006695060022357365,
      "fifteenMinRate": 0.0036382699664488415
    }
  }
}
----

You can get a single metric by specifying the name in the URL path

[source,bash]
.Get the Helidon grpc.requests.meter
----
curl -H "Accept: application/json"  http://localhost:8080/metrics/vendor/grpc.requests.meter
----

[source,json]
.JSON response.
----
{
  "grpc.requests.meter": {
    "count": 0,
    "meanRate": 0.0,
    "oneMinRate": 0.0,
    "fiveMinRate": 0.0,
    "fifteenMinRate": 0.0
  }
}
----

NOTE: You cannot get the individual fields of a metric. For example, you cannot target http://localhost:8080/metrics/vendor/grpc.requests.meter.count

=== Metrics Metadata

Each metric has a associated metadata that describes:

1. name: The name of the metric.
2. units: The unit of the metric such as time (seconds, millisecond), size (bytes, megabytes), etc
3. type: The type of metric: counter, gauge, meter, histogram, timer, etc.

You can get the metadata for any scope, such as /metrics/base, as shown beloww:

[source,bash]
.Get the metrics metadata using HTTP OPTIONS method
----
 curl -X OPTIONS -H "Accept: application/json"  http://localhost:8080/metrics/base
----

[source,json]
.JSON response (truncated)
----
{
  "classloader.currentLoadedClass.count": {
    "unit": "none",
    "type": "counter",
    "description": "Displays the number of classes that are currently loaded in the Java virtual machine.",
    "displayName": "Current Loaded Class Count"
  },
...
  "jvm.uptime": {
    "unit": "milliseconds",
    "type": "gauge",
    "description": "Displays the start time of the Java virtual machine in milliseconds. This attribute displays the approximate time when the Java virtual machine started.",
    "displayName": "JVM Uptime"
  },
...
  "memory.usedHeap": {
    "unit": "bytes",
    "type": "gauge",
    "description": "Displays the amount of used heap memory in bytes.",
    "displayName": "Used Heap Memory"
  }
}
----


=== Application specific metrics data

You can create application specific metrics and integrate them with Helidon using the CDI.
To add a new metric, simply annotate the JAX-RS resource with one of the metric annotations. Metrics can
be injected at the class, method, and field levels.  This document when show examples of all three.

Application metrics must be created and registered in the applicaton MetricRegistry.  The registry
stores metrics and their metadata, plus provides methods to register, create and retrieve metrics and their respective metadata.
The metrics will exist for the lifetime of the application.  For annotated metrics, the creation and registration
is automatically done by Helidon.  Each metric annotation has a set of fields, where some are optional and others are mandatory.
For example, 'name' is an optional metric annotaiton field.

==== Method level metrics

There are 3 metrics that you can use by using the following method annotions:

1. @Counted - Register a Counter metric
2. @Timed - Register a Timer metric
3. @Metered - Register a Timer metric

The following example will demonstrate how to use the @Counted annotation to track the number of times
the /cards endpoint is called.

[source,java]
.Create a new class `GreetingCards' with the following code:
----
package io.helidon.examples.quickstart.mp;

import java.util.Collections;
import javax.enterprise.context.RequestScoped;
import javax.json.Json;
import javax.json.JsonBuilderFactory;
import javax.json.JsonObject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import org.eclipse.microprofile.metrics.annotation.Counted;

@Path("/cards") //<1>
@RequestScoped // <2>
public class GreetingCards {

  private static final JsonBuilderFactory JSON = Json.createBuilderFactory(Collections.emptyMap());

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Counted(name = "any-card", monotonic = true)
  public JsonObject anyCard() throws InterruptedException {
    return createResponse("Here are some random cards ...");
  }

  private JsonObject createResponse(String msg) {
    return JSON.createObjectBuilder().add("message", msg).build();
  }
}
----
<1> This class is annotated with `Path` which sets the path for this resource
as `/cards`
<2> The `RequestScoped` annotation defines that this bean is
request scoped.  The request scope is active only for the duration of
one web service invocation and it is destroyed at the end of that
invocation.
<3> The annotation @Counted will register a counter metric for this method, creating it if neccessary.  The counter is incremened each time the anyCards method is called.
The `name` attribute is optional

NOTE: You must set @Counted monotonic field to `true` to force the count to increment rather than decrement.


[source,java]
.Create a new class `GreetingCards' with the following code:
----
package io.helidon.examples.quickstart.mp;

import java.util.Collections;
import javax.enterprise.context.RequestScoped;
import javax.json.Json;
import javax.json.JsonBuilderFactory;
import javax.json.JsonObject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import org.eclipse.microprofile.metrics.annotation.Counted;

@Path("/cards") //<1>
@RequestScoped // <2>
public class GreetingCards {

  private static final JsonBuilderFactory JSON = Json.createBuilderFactory(Collections.emptyMap());

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Counted(name = "any-card", monotonic = true)
  public JsonObject anyCard() throws InterruptedException {
    return createResponse("Here are some random cards ...");
  }

  private JsonObject createResponse(String msg) {
    return JSON.createObjectBuilder().add("message", msg).build();
  }
}
----
<1> This class is annotated with `Path` which sets the path for this resource
as `/cards`
<2> The `RequestScoped` annotation defines that this bean is
request scoped.  The request scope is active only for the duration of
one web service invocation and it is destroyed at the end of that
invocation.
<3> The annotation @Counted will register a counter metric for this method, creating it if neccessary.  The counter is incremened each time the anyCards method is called.
The `name` attribute is optional


[source,bash]
.Build and run the application, then invoke the application metrics endpoints below
----
curl http://localhost:8080/cards
curl http://localhost:8080/cards
curl http://localhost:8080/metrics/application
----

[source,json]
.JSON response:
----
{
  "io.helidon.examples.quickstart.mp.GreetingCards.any-card":2 // <1>
}
----
<1> The application metrics count will be 2, since you invoked the endpoint twice.

NOTE: Notice the counter is fully qualified.  You can remove the package prefix by using the `absolute=true` field in the @Counted annotation

===== Additional Method level metrics

You can annotate the same method with the other 2 metrics: @Timed and @Metered. When using multiple annoations on a method
you *must* give the metrics different names using the annoation `name` field


[source,java]
.Create a new class `GreetingCards' with the following code:
----
package io.helidon.examples.quickstart.mp;

import java.util.Collections;
import javax.enterprise.context.RequestScoped;
import javax.json.Json;
import javax.json.JsonBuilderFactory;
import javax.json.JsonObject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import org.eclipse.microprofile.metrics.MetricUnits;
import org.eclipse.microprofile.metrics.annotation.Counted;
import org.eclipse.microprofile.metrics.annotation.Metered;
import org.eclipse.microprofile.metrics.annotation.Timed;

@Path("/cards") // <1>
@RequestScoped // <2>
public class GreetingCards {

  private static final JsonBuilderFactory JSON = Json.createBuilderFactory(Collections.emptyMap());

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Counted(name = "cardCount", absolute = true, monotonic = true)
  @Metered(name = "cardMeter", absolute = true, unit = MetricUnits.MILLISECONDS)
  @Timed(name = "cardTimer", absolute = true, unit = MetricUnits.MILLISECONDS)
  public JsonObject anyCard() throws InterruptedException {
    return createResponse("Here are some random cards ...");
  }

  private JsonObject createResponse(String msg) {
    return JSON.createObjectBuilder().add("message", msg).build();
  }
}

----
<1> Specify a custom name and also set `absolute=true` to remove the path prefix from the name
<1> Add the @Metered annotation to get a Meter metric
<2> Add the @Timed annotation to get a Timer metric


[source,json]
.JSON response:
----
{
  "cardCount": 2,
  "cardMeter": {  // <1>
    "count": 2,
    "meanRate": 0.3664337145491488,
    "oneMinRate": 0.4,
    "fiveMinRate": 0.4,
    "fifteenMinRate": 0.4
  },
  "cardTimer": { // <2>
    "count": 2,
    "meanRate": 0.36649792432150535,
    "oneMinRate": 0.4,
    "fiveMinRate": 0.4,
    "fifteenMinRate": 0.4,
    "min": 12944,
    "max": 2078856,
    "mean": 1045900.0,
    "stddev": 1032956.0,
    "p50": 2078856.0,
    "p75": 2078856.0,
    "p95": 2078856.0,
    "p98": 2078856.0,
    "p99": 2078856.0,
    "p999": 2078856.0
  }
}
----
<1> Notice the Meter metric also includes the count field (it is a superset of Counter)
<2> Notice the Timer metric also includes the Meter fields (it is a superset of Meter)


==== Class level metrics

You can collect metrics at the class level to aggregate data from all methods in that class using that same metric.
The following demo introduces a metric to count all card queries.


[source,java]
.Update the `GreetingCards` class with the following code:
----
package io.helidon.examples.quickstart.mp;

import java.util.Collections;
import javax.enterprise.context.RequestScoped;
import javax.json.Json;
import javax.json.JsonBuilderFactory;
import javax.json.JsonObject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import org.eclipse.microprofile.metrics.annotation.Counted;

@Path("/cards")
@RequestScoped
@Counted(name = "totalCards", monotonic = true) // <1>
public class GreetingCards {

  private static final JsonBuilderFactory JSON = Json.createBuilderFactory(Collections.emptyMap());

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Counted(monotonic = true, absolute = true) // <2>
  public JsonObject anyCard() throws InterruptedException {
    return createResponse("Here are some random cards ...");
  }

  @Path("/birthday")
  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Counted(monotonic = true, absolute = true) // <3>
  public JsonObject birthdayCard() throws InterruptedException {
    return createResponse("Here are some birthday cards ...");
  }

  private JsonObject createResponse(String msg) {
    return JSON.createObjectBuilder().add("message", msg).build();
  }
}
----
<1> This class is annotated with `Counter` which agrregates data from all the method level counters
<2> Use `absolute=true` to remove path prefix for method level annatations.
<3> Add a method with a counter metric to get birthday cards

[source,bash]
.Build and run the application, then invoke the application metrics endpoints below
----
curl http://localhost:8080/cards
curl http://localhost:8080/cards/birthday
curl http://localhost:8080/metrics/application
----

[source,json]
.JSON response from /metrics/application
----
{
  "anyCard": 1,
  "birthdayCard": 1,
  "io.helidon.examples.quickstart.mp.totalCards.GreetingCards": 2
}
----
<1> The totalCards count is a total of all the method level counter metrics.

==== Field level metrics

Field level metrics can be injected into an object, but they need to be updated by the application code.  This
example shows how to use a field level counter metric to track cache hits.

[source,java]
.Update the `GreetingCards` class with the following code:
----
package io.helidon.examples.quickstart.mp;

import java.util.Collections;
import java.util.Random;
import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;
import javax.json.Json;
import javax.json.JsonBuilderFactory;
import javax.json.JsonObject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import org.eclipse.microprofile.metrics.Counter;
import org.eclipse.microprofile.metrics.annotation.Counted;
import org.eclipse.microprofile.metrics.annotation.Metric;

@Path("/cards")
@RequestScoped
@Counted(name = "totalCards", monotonic = true)
public class GreetingCards {

  private static final JsonBuilderFactory JSON = Json.createBuilderFactory(Collections.emptyMap());

  @Inject
  @Metric(name = "cacheHits", absolute = true) // <1>
  private Counter cacheHits;

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Counted(monotonic = true, absolute = true)
  public JsonObject anyCard() throws InterruptedException {
    updateStats(); // <2>
    return createResponse("Here are some random cards ...");
  }

  @Path("/birthday")
  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Counted(monotonic = true, absolute = true)
  public JsonObject birthdayCard() throws InterruptedException {
    updateStats();
    return createResponse("Here are some birthday cards ...");
  }

  private JsonObject createResponse(String msg) {
    return JSON.createObjectBuilder().add("message", msg).build();
  }

  private void updateStats() {
    if (new Random().nextInt(3) == 1) {
      cacheHits.inc(); // <3>
    }
  }
}
----
<1> A Counter metric field, `cacheHits`, is automatically injected by Helidon
<2> Call `updateStats()` to update the cache hits
<3> Randomly increment the `cacheHits` Counter.

[source,bash]
.Build and run the application, then invoke the application metrics endpoints below
----
curl http://localhost:8080/cards
curl http://localhost:8080/cards
curl http://localhost:8080/cards/birthday
curl http://localhost:8080/cards/birthday
curl http://localhost:8080/cards/birthday
curl http://localhost:8080/metrics/application
----

[source,json]
.JSON response from /metrics/application
----
{
  "anyCard": 2,
  "birthdayCard": 3,
  "cacheHits": 1,
  "io.helidon.examples.quickstart.mp.totalCards.GreetingCards": 5
}
----
<1> The cache was hit 1 times out of 5 queries

==== Non-injected metrics

==== Tagged metrics


=== Prometheus metrics data
