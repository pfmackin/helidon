///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2019 Oracle and/or its affiliates. All rights reserved.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= Metrics  MP Guide
:description: Helidon metrics s
:keywords: helidon, metrics, metrics, 

This document describes basic examples that use both built-in and custom metrics with Helidon MP.

== What you need

[width=50%,role="flex, sm7"]
|===
|About 30 minutes
|<<about/03_prerequisites.adoc,Helidon Prerequisites>>
|===

TIP: See the full Microprofile Metrics specification at https://github.com/eclipse/microprofile-metrics/releases/tag/1.1

=== Create a sample MP project

Generate the project sources using the Helidon MP Maven archetype.
The result is a simple project that can be used for the examples in this guide.

[source,bash,subs="attributes+"]
.Run the Maven archetype
----
mvn archetype:generate -DinteractiveMode=false \
    -DarchetypeGroupId=io.helidon.archetypes \
    -DarchetypeArtifactId=helidon-quickstart-mp \
    -DarchetypeVersion={helidon-version} \
    -DgroupId=io.helidon.examples \
    -DartifactId=helidon-quickstart-mp \
    -Dpackage=io.helidon.examples.quickstart.mp
----

=== Using the built-in metrics

Helidon provides 3 scopes of metrics data as shown below. The base and vendor metrics are automatically enabled in Helidon.
The /metrics endpoint will return data for all scopes.

1. /metrics/base - Base metrics data as specified by the MicroProfile Metrics specification
2. /metrics/vendor - Helidon specific metrics data
3. /metrics/application - Application specific metrics data


This example will demonstrate how to use the built-in metrics.  These examples are all executed
from the root directory of your project (helidon-quickstart-mp)

[source,bash]
.Build the application, skipping unit tests, then run it
----
mvn package -DskipTests=true
java -jar target/helidon-quickstart-mp.jar
----

NOTE: Metrics can be returned in either text format (the default), or JSON.  The text format uses OpenMetrics Text Format,
see https://prometheus.io/docs/instrumenting/exposition_formats/#text-format-details

[source,bash]
.Verify the metrics endpoint in a new terminal window
----
curl http://localhost:8080/metrics
----

[source,text]
.Text response.
----
# TYPE base:classloader_current_loaded_class_count counter
# HELP base:classloader_current_loaded_class_count Displays the number of classes that are currently loaded in the Java virtual machine.
base:classloader_current_loaded_class_count 7511
# TYPE base:classloader_total_loaded_class_count counter
# HELP base:classloader_total_loaded_class_count Displays the total number of classes that have been loaded since the Java virtual machine has started execution.
base:classloader_total_loaded_class_count 7512
...
----

Get the same data in JSON format.

[source,bash]
.Verify the metrics endpoint with an HTTP accept header
----
curl -H "Accept: application/json"  http://localhost:8080/metrics
----

[source,json]
.JSON response.
----
{
  "base": {
    "classloader.currentLoadedClass.count": 7534,
    "classloader.totalLoadedClass.count": 7538,
    "classloader.totalUnloadedClass.count": 1,
    "cpu.availableProcessors": 4,
    "cpu.systemLoadAverage": 2.83349609375,
    "gc.PS MarkSweep.count": 2,
    "gc.PS MarkSweep.time": 77,
    "gc.PS Scavenge.count": 5,
    "gc.PS Scavenge.time": 37,
    "jvm.uptime": 727588,
    "memory.committedHeap": 284164096,
    "memory.maxHeap": 3817865216,
    "memory.usedHeap": 53283088,
    "thread.count": 44,
    "thread.daemon.count": 35,
    "thread.max.count": 44
  },
  "vendor": {
    "grpc.requests.count": 0,
    "grpc.requests.meter": {
      "count": 0,
      "meanRate": 0.0,
      "oneMinRate": 0.0,
      "fiveMinRate": 0.0,
      "fifteenMinRate": 0.0
    },
    "requests.count": 6,
    "requests.meter": {
      "count": 6,
      "meanRate": 0.008275992296704147,
      "oneMinRate": 0.01576418632772332,
      "fiveMinRate": 0.006695060022357365,
      "fifteenMinRate": 0.0036382699664488415
    }
  }
}
----

You can get a single metric by specifying the name in the URL path

[source,bash]
.Get the Helidon grpc.requests.meter
----
curl -H "Accept: application/json"  http://localhost:8080/metrics/vendor/grpc.requests.meter
----

[source,json]
.JSON response.
----
{
  "grpc.requests.meter": {
    "count": 0,
    "meanRate": 0.0,
    "oneMinRate": 0.0,
    "fiveMinRate": 0.0,
    "fifteenMinRate": 0.0
  }
}
----

NOTE: You cannot get the individual fields of a metric. For example, you cannot target http://localhost:8080/metrics/vendor/grpc.requests.meter.count

=== Metrics Metadata

Each metric has a associated metadata that describes:

1. name: The name of the metric.
2. units: The unit of the metric such as time (seconds, millisecond), size (bytes, megabytes), etc
3. type: The type of metric: counter, gauge, meter, histogram, timer, etc.

You can get the metadata for any scope, such as /metrics/base, as shown beloww:

[source,bash]
.Get the metrics metadata using HTTP OPTIONS method
----
 curl -X OPTIONS -H "Accept: application/json"  http://localhost:8080/metrics/base
----

[source,json]
.JSON response (truncated)
----
{
  "classloader.currentLoadedClass.count": {
    "unit": "none",
    "type": "counter",
    "description": "Displays the number of classes that are currently loaded in the Java virtual machine.",
    "displayName": "Current Loaded Class Count"
  },
...
  "jvm.uptime": {
    "unit": "milliseconds",
    "type": "gauge",
    "description": "Displays the start time of the Java virtual machine in milliseconds. This attribute displays the approximate time when the Java virtual machine started.",
    "displayName": "JVM Uptime"
  },
...
  "memory.usedHeap": {
    "unit": "bytes",
    "type": "gauge",
    "description": "Displays the amount of used heap memory in bytes.",
    "displayName": "Used Heap Memory"
  }
}
----


=== Application specific metrics data

You can create application specific metrics and integrate them with Helidon using the CDI.
To add a new metric, simply annotate the JAX-RS resource with one of the metric annotations. Metrics can
be injected at the class, method, and field levels.  This document when show examples of all three.

==== Method level metrics

The following example will demonstrate how to use the @Counted annotation to track the number of times
the /cards/birthday endpoint is called.

NOTE: You must set @Counted monotonic field to `true` to force the count to increment rather than decrement.

[source,java]
.Create a new class `GreetingCards' with the following:
----
package io.helidon.examples.quickstart.mp;

import java.util.Collections;
import javax.enterprise.context.RequestScoped;
import javax.json.Json;
import javax.json.JsonBuilderFactory;
import javax.json.JsonObject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import org.eclipse.microprofile.metrics.annotation.Counted;

@Path("/cards") // <1>
@RequestScoped // <2>
public class GreetingCards {

  private static final JsonBuilderFactory JSON = Json.createBuilderFactory(Collections.emptyMap());

  @Path("/birthday") // <3>
  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Counted(name = "birthday-cards", monotonic = true) // <4>
  public JsonObject birthday() throws InterruptedException {
    return createResponse("Here are some birthday cards ...");
  }

  private JsonObject createResponse(String msg) {
    return JSON.createObjectBuilder().add("message", msg + " response").build();
  }
}
----
<1> This class is annotated with `Path` which sets the path for this resource
as `/cards`
<2> The `RequestScoped` annotation defines that this bean is
request scoped.  The request scope is active only for the duration of
one web service invocation and it is destroyed at the end of that
invocation.
<3> The path for this method is `cards\birthday`
<4> The annotation @Counted will bind a counter metric to this method.  The counter is incremened each time the birthday method is called.
The `name` attribute is optional


[source,bash]
.Build and run the application, then invoke the application metrics endpoints below
----
curl http://localhost:8080/cards/birthday
curl http://localhost:8080/cards/birthday
curl http://localhost:8080/metrics/application
----

[source,json]
.JSON response:
----
{
  "io.helidon.examples.quickstart.mp.GreetingCards.birthday-cards": 2 // <1>
}
----
<1> The application metrics count will be 2, since you called the birthday endpoint twice.

Notice the counter is fully qualified.  You remove the package prefix by using the `absolute=true` field in the @Counted annotation

[source,java]
.Modify the @Counted annotation in `GreetingCards.java'
----
  @Counted(name = "birthday-cards", monotonic = true, absolute = true)
----

[source,bash]
.Build and run the application, then invoke the application metrics endpoints below
----
curl http://localhost:8080/cards/birthday
curl http://localhost:8080/metrics/application
----

[source,json]
.JSON response:
----
{
  "birthday-cards": 1 // <1>
}
----
<1> The application metrics count will use the short name, `birthday-cards`.

==== Class level metrics

You can collect metrics at the class level to aggregate data from all methods in that class using that same metric.
The following demo introduces a metric to count all card queries.


[source,java]
.Update the `GreetingCards` class with the following code:
----
package io.helidon.examples.quickstart.mp;

import java.util.Collections;
import javax.enterprise.context.RequestScoped;
import javax.json.Json;
import javax.json.JsonBuilderFactory;
import javax.json.JsonObject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import org.eclipse.microprofile.metrics.annotation.Counted;

@Path("/cards")
@RequestScoped
@Counted(name = "all-cards", monotonic = true, absolute = true) // <1>
public class GreetingCards {

  private static final JsonBuilderFactory JSON = Json.createBuilderFactory(Collections.emptyMap());

  @Path("/birthday")
  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Counted(name = "birthday-cards", monotonic = true, absolute = true)
  public JsonObject birthday() throws InterruptedException {
    return createResponse("Here are some birthday cards ...");
  }

  @Path("/holiday")
  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Counted(name = "holiday-cards", monotonic = true, absolute = true)
  public JsonObject holiday() throws InterruptedException {  // <2>
    return createResponse("Here are some holiday cards ...");
  }

  private JsonObject createResponse(String msg) {
    return JSON.createObjectBuilder().add("message", msg).build();
  }
}
----
<1> This class is annotated with `Counter` which agrregates data from all the method level counters
<2> Add a method with a counter metric to get holiday cards

[source,bash]
.Build and run the application, then invoke the application metrics endpoints below
----
curl http://localhost:8080/cards/birthday
curl http://localhost:8080/cards/holiday
curl http://localhost:8080/metrics/application
----

[source,json]
.JSON response from /metrics/application
----
{
  "birthday-cards": 1,
  "holiday-cards": 1,
  "io.helidon.examples.quickstart.mp.all-cards.GreetingCards": 2
}
----
<1> The all-cards count is a total of all the method level counter metrics.  Notice that the class level
name is fully qualified even though `absolute=true` was specified.

==== Field level metrics

Field level metrics can be injected into an object, but they need to be updated by the application code.  This
example shows how to use a field level counter metric to track cache hits.

[source,java]
.Update the `GreetingCards` class with the following code:
----
package io.helidon.examples.quickstart.mp;

import java.util.Collections;
import java.util.Random;
import javax.enterprise.context.RequestScoped;
import javax.inject.Inject;
import javax.json.Json;
import javax.json.JsonBuilderFactory;
import javax.json.JsonObject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import org.eclipse.microprofile.metrics.Counter;
import org.eclipse.microprofile.metrics.annotation.Counted;
import org.eclipse.microprofile.metrics.annotation.Metric;

@Path("/cards")
@RequestScoped
@Counted(name = "all-cards", monotonic = true)
public class GreetingCards {

  private static final JsonBuilderFactory JSON = Json.createBuilderFactory(Collections.emptyMap());

  @Inject
  @Metric(name = "cacheHits", absolute = true) // <1>
  private Counter cacheHits;

  @Path("/birthday")
  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Counted(name = "birthday-cards", monotonic = true, absolute = true)
  public JsonObject birthday() throws InterruptedException {
    checkCache(); // <2>
    return createResponse("Here are some birthday cards ...");
  }

  @Path("/holiday")
  @GET
  @Produces(MediaType.APPLICATION_JSON)
  @Counted(name = "holiday-cards", monotonic = true, absolute = true)
  public JsonObject holiday() throws InterruptedException { // <3>
    checkCache();
    return createResponse("Here are some holiday cards ...");
  }

  private JsonObject createResponse(String msg) {
    checkCache();
    return JSON.createObjectBuilder().add("message", msg).build();
  }

  private void checkCache() {
    if (new Random().nextInt(3) == 1) {
      cacheHits.inc(); // <3>
    }
  }
}
----
<1> A Counter metric field, `cacheHits`, is automatically injected by Helidon
<2> Call `checkCache()` to update the cache hits
<3> Randomly increment the `cacheHits` Counter.

[source,bash]
.Build and run the application, then invoke the application metrics endpoints below
----
curl http://localhost:8080/cards/birthday
curl http://localhost:8080/cards/birthday
curl http://localhost:8080/cards/birthday
curl http://localhost:8080/cards/holiday
curl http://localhost:8080/cards/holiday
curl http://localhost:8080/metrics/application
----

[source,json]
.JSON response from /metrics/application
----
{
  "birthday-cards": 3,
  "cacheHits": 2,  // <1>
  "holiday-cards": 2,
  "io.helidon.examples.quickstart.mp.all-cards.GreetingCards": 5
}
----
<1> The cache was hit 2 times out of 5 queries



==== Tagged metrics


=== Prometheus metrics data
