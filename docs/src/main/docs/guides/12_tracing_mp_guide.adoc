///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2019 Oracle and/or its affiliates. All rights reserved.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= Tracing MP Guide
:description: Helidon tracing
:keywords: helidon, tracing, microprofile, guide
:toc:

This guide describes how to create a sample MicroProfile (MP) project
that can be used to run some basic examples using tracing with Helidon MP.

== What you need

[width=50%,role="flex, sm7"]
|===
|About 30 minutes
|<<about/03_prerequisites.adoc,Helidon Prerequisites>>
|===

== Getting started with tracing

Distributed tracing is a critical feature of micro-service based applications since it traces workflow both
within a service and across multiple services.  This gives you insight to sequence and timing data for specific blocks of work,
which helps you identify performance and operational issues.  Helidon MP includes support for distributed tracing
through the https://github.com/helm/helm[OpenTracing API].  Tracing is integrated with WebServer, gRPC Server,
and Security using either the https://zipkin.io[Zipkin] or https://www.jaegertracing.io[Jaeger] tracers.
The examples in this guide will use Zipkin, and traces will be viewed using both the Zipkin API and UI.

=== Create a sample Helidon MP project

Use the Helidon MP Maven archetype to create a simple project that can be used for the examples in this guide.

[source,bash,subs="attributes+"]
.Run the Maven archetype:
----
mvn archetype:generate -DinteractiveMode=false \
    -DarchetypeGroupId=io.helidon.archetypes \
    -DarchetypeArtifactId=helidon-quickstart-mp \
    -DarchetypeVersion={helidon-version} \
    -DgroupId=io.helidon.examples \
    -DartifactId=helidon-quickstart-mp \
    -Dpackage=io.helidon.examples.quickstart.mp
----

[source,bash]
.The project will be built and run from the `helidon-quickstart-mp` directory:
----
cd helidon-quickstart-mp
----

=== Spans and Traces

A _span_ is the basic unit of work done within a single service, on a single host.  A _trace_ contains a collection of spans, where spans
are organzied as directed acylic graphs (DAG) and can belong to multiple services, running on multiple hosts.  The _OpenTracing Data Model_
describes the details at https://opentracing.io/specification[The OpenTracing Semantic Specification].
For example, when you invoke a REST API call, Helidon creates a unique `trace` to tracke the spans.  Then, spans are created and tracked
during execution of the REST request.  The following example demonstrates this using a simple trace.

[source,bash]
Run Zipkin within a docker container.
----
.docker run -d --name zipkin -p 9411:9411 openzipkin/zipkin
----

As mentioned, Helidon include built-in support for tracing.  To enable it you need to update the pom.xml file and
add the following to the `<dependencies>` section (*not* `<dependencyManagement>`):

[source,xml]
.Add the following line to `META-INF/microprofile-tracing.properties`:
----
<dependency>
<groupId>io.helidon.tracing</groupId>
<artifactId>helidon-tracing-zipkin</artifactId>
</dependency>
----

[source,bash]
.Add the following line to `META-INF/microprofile-tracing.properties`:
----
tracing.service=helidon-mp-1
----

[source,bash]
.Build the application, skipping unit tests, then run it:
----
mvn package -DskipTests=true
java -jar target/helidon-quickstart-mp.jar
----

[source,bash]
.Run the curl command in a new terminal window and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "Hello World!"
}
----

===== Viewing tracing using Zipkin REST API

Because you have tracing enable, that endpoint invocation resulted in a new trace being created.
First, get the service that Zipkin is tracing using the Zipkin API.

[source,bash]
.Run the curl command in a new terminal window and check the response:
----
curl http://localhost:9411/api/v2/services
...
["helidon-mp-1"] // <1>
----
<1> This is the tracing service name specified in `META-INF/microprofile-tracing.properties`.

Each span used by a service has a name, which is unique within a trace. If you
invoke the `/greet` endpoint multiple times, you will still get the same set
of names.

[source,bash]
.Invoke the endpoint below and check the response:
----
curl http://localhost:9411/api/v2/spans
...
[ // <1> <span>
  "content-read",
  "content-write",
  "get:io.helidon.examples.quickstart.mp.greetresource.getdefaultmessage",
  "security",
  "security:atn",
  "security:atz",
  "security:response"
]
----
<1> These are the span names.  If you invoke the `/greet` endpoint again, then
invoke the `/spans` endpoint you will get the same response.

Finally, lets get the contents of the trace. Notice that each span has a `parentId` field,
except the `get:io.helidon.examples.quickstart.mp.greetresource.getdefaultmessage` span,
which is the root.

[source,bash]
.Invoke the endpoint below and check the response:
----
curl -X GET "http://localhost:9411/api/v2/traces?serviceName=helidon-mp-1&limit=1" -H "accept: application/json"  // <1>
...
[
  [ // <1>
    {
      "traceId": "2e0af8866efdef35",
      "parentId": "2e0af8866efdef35",
      "id": "b5d61690f230fde4",
      "kind": "SERVER",
      "name": "content-read",
      "timestamp": 1568077339998659,
      "duration": 41,
      "localEndpoint": {
        "serviceName": "helidon-mp-1",
        "ipv4": "192.168.1.115"
      },
      "tags": {
        "requested.type": "java.io.InputStream"
      }
    },
...
(truncated)
]

----
<1> Get the oldest trace only using `limit=1` query param.  There are other query params that lets you restrict
results to a specific time window.
<2> The request will return seven spans, one for each name, along with an unamed JSON node, which
is the status node.

===== Viewing tracing using Zipkin UI

Even with a tracing trivial example, the tracing output data is verbose and can be difficult to interpret using the REST API.  Zipkin
offers a web-based UI at http://localhost:9411/zipkin, where you can see a visual representation of the same data and the
relationship between spans within a trace, and even across services.

===== Environment variable override

An environment variable has a higher precedence than the tracing properties file.

[source,bash]
.Set the environment variable and restart the application:
----
export APP_GREETING=HelloFromEnvironment
java -jar target/helidon-quickstart-mp.jar
----

[source,bash]
.Invoke the endpoint below and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromEnvironment World!" // <1>
}
----
<1> The environment variable took precedence over the value in `META-INF/microprofile-tracing.properties`.

===== System property override

A system property has a higher precedence than environment variables.

[source,bash]
.Restart the application with a system property.  The `app.greeting` environment variable is still set:
----
java -Dapp.greeting="HelloFromSystemProperty"  -jar target/helidon-quickstart-mp.jar
----

[source,bash]
.Invoke the endpoint below and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromSystemProperty World!" // <1>
}
----
<1> The system property took precedence over both the environment variable and `META-INF/microprofile-tracing.properties`.

== Custom tracing sources

To use custom tracing sources, your application needs to use a `Tracing` object when
creating a `Server` object.  When you use a `Tracing` object, you are in full control of
all tracing sources and precedence. By default, the environment variable and system property
sources are enabled, but you can disable them using the `disableEnvironmentVariablesSource` and `disableSystemPropertiesSource`
methods.

This section will show you how to use a custom tracing with various sources, formats, and precedence rules.

=== Full list of tracing sources

Here is the full list of external tracing sources that use can use programmatically.

1. Java system properties - the property is a name/value pair.
2. Environment variables - the property is a name/value pair.
3. Resources in the classpath - the contents of the resource is parsed according to its inferred format.
4. File - the contents of the file is parsed according to its inferred format.
5. Directory - each non-directory file in the directory becomes a tracing entry: the file name is the key.
and the contents of that file are used as the corresponding tracing String value.
6. A URL resource - contents is parsed according to its inferred format.

You can also define custom sources, such as Git, and use them in your Helidon application.
See <<tracing/06_advanced-tracing.adoc,Advanced Tracing>> for more information.

=== Classpath sources

The first custom resource example demonstrates how to add a second internal tracing resource that is discovered in the `classpath`.
The code needs to build a `Tracing` object, which in turn is used to build the `Server` object.  The `Tracing` object is built using a `Tracing.Builder`,
which lets you inject any number of sources into the builder.  Furthermore, you can set precedence for the sources.
The first source has highest precedence, then the next has second highest, and so forth.

[source,text]
.Add a resource file, named `tracing.properties` to the `resources` directory with the following contents:
----
app.greeting=HelloFrom-tracing.properties
----

[source,java]
.Update the `Main` class; 1) Add new imports, 2) Replace the `startServer` method, 3) Add `buildTracing` method:
----
import io.helidon.tracing.Tracing; //<1>
import static io.helidon.tracing.TracingSources.classpath;
...

  static Server startServer() {
        return Server.builder()
            .tracing(buildTracing()) // <2>
            .build()
            .start();
    }

  private static Tracing buildTracing() {
    return Tracing.builder()
        .disableEnvironmentVariablesSource() // <3>
        .sources(
            classpath("tracing.properties"), // <4>
            classpath("META-INF/microprofile-tracing.properties")) // <5>
        .build();
  }
----
<1> Import tracing classes.
<2> Pass the custom `Tracing` object to the `Server.Builder`.
<3> Disable the environment variables as a source.
<4> Specify the new tracing.properties resource that is in the `classpath`.
<5> You must specify the existing `META-INF/microprofile-tracing.properties` or Helidon will not use it as a tracing source
even though it is considered a default source.

[source,bash]
.Build and run the application (without the system property).  Invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFrom-tracing.properties World!"
}
----
<1> The greeting was picked up from `tracing.properties`, overriding the value in `META-INF/microprofile-tracing.properties`.

NOTE: It is important to remember that tracing from all sources get merged internally.  If you have the same
 tracing property in multiple sources then only the one with highest precedence will be used at runtime.
This is true even the same property comes from sources with different formats.

Swap the source order and run the test again.

[source,java]
.Update the `Main` class and replace the 'buildTracing` method:
----
  private static Tracing buildTracing() {
      return Tracing.builder()
          .disableEnvironmentVariablesSource()
          .sources(
              classpath("META-INF/microprofile-tracing.properties"), // <1>
              classpath("tracing.properties"))
          .build();
  }
----
<1> Swap the source order, putting `META-INF/microprofile-tracing.properties` first.

[source,bash]
.Build and run the application, then invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromMPTracing World!" // <1>
}
----
<1> The file `META-INF/microprofile-tracing.properties` was used to get the greeting since it now has precedence over `tracing.properties`.

=== External file sources

You can move all or part of your tracing to external files, making them optional or mandatory.  The obvious advantage to this
approach is that you do not need to rebuild your application to change tracing.  In the following
example, the `app.greeting` tracing property will be added to `tracing-file.properties`.

[source,bash]
.Unset the environment variable so that `disableEnvironmentVariablesSource` doesn't need to be called:
----
unset APP_GREETING
----

[source,bash]
.Create a file named `tracing-file.properties` in the `helidon-quickstart-mp` directory with the following contents:
----
app.greeting=HelloFromTracingFile
----

[source,java]
.Update the `Main` class; 1) Add new import and 2) Replace the 'buildTracing` method:
----
import static io.helidon.tracing.TracingSources.file;
...

  private static Tracing buildTracing() {
      return Tracing.builder()
          .sources(
              file("tracing-file.properties"), // <1>
              classpath("META-INF/microprofile-tracing.properties"))
          .build();
  }
----
<1> Add mandatory tracing file.

[source,bash]
.Build and run the application, then invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromTracingFile World!"
}
----
<1> The tracing property from the file `tracing-file.properties` takes precedence.

NOTE: If you want the tracing file to be optional, you must use the `optional` method with `sources`,
otherwise Helidon will generate an error during startup as shown below.  This is true for both `file` and
`classpath` sources.  By default these sources are mandatory.

[source,java]
.Update the `Main` class and replace the 'buildTracing` method:
----
  private static Tracing buildTracing() {
      return Tracing.builder()
          .sources(
              file("missing-file"), // <1>
              classpath("META-INF/microprofile-tracing.properties"))
          .build();
  }
----
<1> Specify a file that doesn't exist.

[source,bash]
.Build then start the application and you will see the following output:
----
Exception in thread "main" io.helidon.tracing.TracingException: Cannot load data from mandatory source FileTracing[missing-file]. File `missing-file` not found.
----

To fix this, use the `optional` method as shown below, then rerun the test.

----
...
    file("missing-file").optional(), // <1>

----
<1> The `missing-file` tracing file is now optional.

=== Directory source

A directory source treats every file in the directory as a key, and the file contents as the value.  The
following example include a directory source as highest precedence.

[source,bash]
.Create a new directory `helidon-quickstart-mp/conf` then create a file named `app.greeting` in that directory with the following contents:
----
HelloFromFileInDirectoryConf
----

[source,java]
.Update the `Main` class; 1) Add new import and 2) Replace the 'buildTracing` method:
----
import static io.helidon.tracing.TracingSources.directory;
...

  private static Tracing buildTracing() {
      return Tracing.builder()
          .sources(
              directory("conf"), // <1>
              classpath("tracing.properties").optional(),
              classpath("META-INF/microprofile-tracing.properties"))
          .build();
  }
----
<1> Add mandatory tracing directory.

[source,bash]
.Build and run the application, then invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromFileInDirectoryConf World!"
}
----
<1> The greeting was fetched from the file named `app.greeting`.

==== Exceeding three sources

If you have more than three sources, you need to use a `TracingSources` class to create a
custom source list as shown below.

[source,java]
.Update the `Main` class; 1) Add new import and 2) Replace the 'buildTracing` method:
----
import io.helidon.tracing.TracingSources;
...

  private static Tracing buildTracing() {
      return Tracing.builder()
          .sources(TracingSources.create(   // <1>
              directory("conf"),
              file("tracing-file.properties"),
              classpath("tracing.properties").optional(),
              classpath("META-INF/microprofile-tracing.properties")))
          .build();
  }
----
<1> Create a list of four sources using `TracingSources.create` method.

[source,bash]
.Build and run the application, then invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...

{
  "message": "HelloFromFileInDirectoryConf World!"
}
----

=== Meta-tracing

Instead of directly specifying the tracing sources in your code, you can use meta-tracing in a file that declares
the tracing sources and their attributes. This requires using the `Tracing.loadSourcesFrom` method rather than a `Tracing.Buider`
object. The contents of the meta-tracing file needs to be in JSON, YAML, or HOCON format. YAML is used in the following example.

[source,bash]
.Create a file named `meta-tracing.yaml` in the `helidon-quickstart-mp` directory with the following contents:
----
sources:
  - type: "classpath" // <1>
    properties:
      resource: "META-INF/microprofile-tracing.properties" // <2>
----
<1> The source type.
<2> The name of the mandatory tracing resource.


[source,java]
.Update the `Main` class and replace the 'buildTracing` method:
----
  private static Tracing buildTracing() {
      return Tracing.loadSourcesFrom( file("meta-tracing.yaml")); // <1>
  }
----
<1> Specify the meta-tracing file, which contains a single tracing source.

[source,bash]
.Build and run the application, then invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromMPTracing World!" // <1>
}
----
<1> The `META-INF/microprofile-tracing.properties` resource file was used to get the greeting.

The source precedence order in a meta-tracing file is the order of appearance in the file.
This is demonstrated below where the `tracing-file.properties` has highest precedence.

[source,bash]
.Replace the contents of the `meta-tracing.yaml` file:
----
sources:
  - type: "file" // <1>
    properties:
      path: "./tracing-file.properties" // <2>
  - type: "classpath"
    properties:
      resource: "META-INF/microprofile-tracing.properties"
  - type: "file"
    properties:
      path: "optional-tracing-file"
      optional: true  // <3>
----
<1> The source type specifies a file.
<2> The name of the mandatory tracing file.
<3> Specify that the `optional-tracing-file` file is optional.

[source,bash]
.Restart the application, then invoke the endpoint below and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromTracingFile World!" // <1>
}
----
<1> The `tracing-file.properties` source now takes precedence.

When using a meta-tracing file, you need to explicitly include both environment variables and system properties as
a source if you want to use them.

[source,bash]
.Replace the contents of the `meta-tracing.yaml` file:
----
sources:
  - type: "environment-variables" // <1>
  - type: "system-properties" // <2>
  - type: "classpath"
    properties:
      resource: "META-INF/microprofile-tracing.properties"
  - type: "file"
    properties:
      path: "./tracing-file.properties"
----
<1> Environment variables are now used as a source.
<2> System properties are now used as a source.


You can re-run the previous tests that exercised environment variables and system properties.  Swap the two types to see
the precedence change.  Be sure to unset APP_GREETING after you finish testing.

== Accessing Tracing within an application

You have used Helidon to customize tracing behavior from your code using the `Tracing` and
`Tracing.Builder` classes.  The examples in this section will demonstrate how to access that tracing data
at runtime.  As discussed previously, Helidon reads tracing from a tracing source, which uses a tracing parser
to translate the source into an in-memory tree which represents the tracing’s structure and values.
Your application uses the `Tracing` object to access the in-memory tree, retrieving tracing data.

An in-memory tracing tree, once loaded, is immutable, even though the data in the underlying tracing sources can
change over time.  Your application can find out metadata about a loaded in-memory tracing and can track changes
in tracing sources

The generated project already accesses tracing data in the `GreetingProvider` class  as  follows:

[source,java]
.View the following code from `GreetingProvider.java`:
----
@ApplicationScoped // <1>
public class GreetingProvider {
    private final AtomicReference<String> message = new AtomicReference<>(); // <2>

    @Inject
    public GreetingProvider(@TracingProperty(name = "app.greeting") String message) {   // <3>
        this.message.set(message);
    }

    String getMessage() {
        return message.get();
    }

    void setMessage(String message) {
        this.message.set(message);
    }
}
----
<1> This class is application scoped so a single instance of `GreetingProvider` will be shared across the entire application.
<2> Define a thread safe reference that will refer to the message member variable.
<3> The value of the tracing property `app.greeting` is injected into the `GreetingProvider`.
constructor as a `String` parameter named `message`.


===== Injecting at field level

You can inject tracing at the field level as shown below.  Use the `volatile` keyword to make
this field thread safe since you cannot use `AtomicReference` with field level injection.

[source,yaml]
.Update the  `meta-tracing.yaml` with the following contents:
----
sources:
  - type: "classpath"
    properties:
      resource: "META-INF/microprofile-tracing.properties"  <1>
----
<1> This example only uses the default classpath source.

[source,java]
.Update the following code from `GreetingProvider.java`:
----
@ApplicationScoped
public class GreetingProvider {

    @Inject
    @TracingProperty(name = "app.greeting") // <1>
    private volatile String message; // <2>

    String getMessage() {
        return message;
    }

    void setMessage(String message) {
        this.message = message;
    }
}
----
<1> Inject the value of `app.greeting` into the `GreetingProvider` object.
<2> Define a class member variable to hold the greeting.

[source,bash]
.Build and run the application, then invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromMPTracing World!"
}
----

===== Injecting the Tracing object

You can inject the `Tracing` object into the class and access it directly as shown below.
This object is not initialized when the `GreetingProvider` constructor is called, so you need to provide
a method (`onStartup`) that observes `@Initialized` so you know the object is ready for
use.

[source,java]
.Update the `GreetingProvider.java` file; 1) Add new imports and 2) Replace the `GreetingProvider` class:
----
 // <1>
import io.helidon.tracing.Tracing;
import javax.enterprise.context.Initialized;
import javax.enterprise.event.Observes;
...

@ApplicationScoped
public class GreetingProvider {
    private final AtomicReference<String> message = new AtomicReference<>();

    @Inject
    Tracing tracing;  // <2>

    public void onStartUp(@Observes @Initialized(ApplicationScoped.class) Object init) {
        message.set(tracing.get("app.greeting").asString().get()); // <3>
    }

    String getMessage() {
        return message.get();
    }

    void setMessage(String message) {
        this.message.set(message);
    }
}
----
<1> Add three new imports.
<2> Inject the `Tracing` object into the `GreetingProvider` object.
<3> Get the `app.greeting` value from the `Tracing` object and set the member variable.

[source,bash]
.Build and run the application, then invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromMPTracing World!"
}
----


===== Navigating the Tracing tree

Helidon offers a variety of methods to access in-memory tracing.  These can be categorized as _key access_ or _tree navigation_.
You have been using _key access_ for all of the examples to this point.  For example `app.greeting` is accessing
the `greeting` child node of the `app` parent node.  There are many options for access this data using navigation
methods as described in <<tracing/03_hierarchical-features.adoc,Hierarchical Tracing>> and <<tracing/06_advanced-tracing.adoc,Advanced Tracing>>.
This simple example below demonstrates how to access a child node as a detached tracing sub-tree.

[source,yaml]
.Create a file `tracing-file.yaml` in the `helidon-quickstart-mp` directory and add the following contents:
----
app:
  greeting:
    sender: Joe
    message: Hello-from-tracing-file.yaml
----

[source,yaml]
.Update the  `meta-tracing.yaml` with the following contents:
----
sources:
  - type: "classpath"
    properties:
      resource: "META-INF/microprofile-tracing.properties"
  - type: "file"
    properties:
      path: "./tracing-file.yaml"
----

[source,java]
.Replace `GreetingProvider` class with the following code:
----
@ApplicationScoped
public class GreetingProvider {
    private final AtomicReference<String> message = new AtomicReference<>();
    private final AtomicReference<String> sender = new AtomicReference<>();

    @Inject
    Tracing tracing;

    public void onStartUp(@Observes @Initialized(ApplicationScoped.class) Object init) {
        Tracing appNode = tracing.get("app.greeting"); // <1>
        message.set(appNode.get("message").asString().get());  // <2>
        sender.set(appNode.get("sender").asString().get());   // <3>
    }

    String getMessage() {
        return sender.get() + " says " + message.get();
    }

    void setMessage(String message) {
        this.message.set(message);
    }
}
----
<1> Get the tracing subtree where the `app.greeting` node is the root.
<2> Get the value from the `message` `Tracing` node.
<3> Get the value from the `sender` `Tracing` node.

[source,bash]
.Build and run the application, then invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "Joe says Hello-from-tracing-file.yaml World!"
}
----

== Integration with Kubernetes

The following example uses a Kubernetes TracingMap to pass the tracing data to your Helidon application deployed to Kubernetes.
When the pod is created, Kubernetes will automatically create a local file within the container that has the contents of the
tracing file that is used for the TracingMap.  This example will create the file at `/etc/tracing/tracing-file.properties`.

[source,java]
.Update the `Main` class and replace the 'buildTracing` method:
----
  private static Tracing buildTracing() {
      return Tracing.builder()
          .sources(
              file("/etc/tracing/tracing-file.properties").optional(), // <1>
              classpath("META-INF/microprofile-tracing.properties")) // <2>
          .build();
  }
----
<1> The `app.greeting` value will be fetched from `/etc/tracing/tracing-file.properties` within the container.
<2> The server port is specified in `META-INF/microprofile-tracing.properties` within the `helidon-quickstart-mp.jar`.

[source,java]
.Update the following code from `GreetingProvider.java`:
----
@ApplicationScoped
public class GreetingProvider {

    @Inject
    @TracingProperty(name = "app.greeting") // <1>
    private volatile String message; // <2>

    String getMessage() {
        return message;
    }

    void setMessage(String message) {
        this.message = message;
    }
}
----

[source,bash]
.Build and run the application, then invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromTracingFile World!"
}
----

[source,bash]
.Stop the application and build the docker image:
----
docker build -t helidon-tracing-mp .
----

[source,bash]
.Generate a TracingMap from `tracing-file.properties`:
----
kubectl create tracingmap helidon-tracingmap --from-file tracing-file.properties
----

[source,bash]
.View the contents of the TracingMap:
----
kubectl get tracingmap helidon-tracingmap -o yaml
...
apiVersion: v1
data:
  tracing-file.properties: |   // <1>
    app.greeting=HelloFromTracingFile   // <2>
kind: TracingMap
...
----
<1> The file `tracing-file.properties` will be created within the Kubernetes container.
<2> The `tracing-file.properties` file will have this single property defined.


[source,yaml]
.Create the Kubernetes YAML specification, named `k8s-tracing.yaml`, with the following contents:
----
kind: Service
apiVersion: v1
metadata:
  name: helidon-tracing // <1>
  labels:
    app: helidon-tracing
spec:
  type: NodePort
  selector:
    app: helidon-tracing
  ports:
    - port: 8080
      targetPort: 8080
      name: http
---
kind: Deployment
apiVersion: extensions/v1beta1
metadata:
  name: helidon-tracing
spec:
  replicas: 1 // <2>
  template:
    metadata:
      labels:
        app: helidon-tracing
        version: v1
    spec:
      containers:
        - name: helidon-tracing
          image: helidon-tracing-mp
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
          volumeMounts:
            - name: tracing-volume
              mountPath: /etc/tracing // <3>
      volumes:
        - name: tracing-volume
          tracingMap:
            # Provide the name of the TracingMap containing the files you want
            # to add to the container
            name:  helidon-tracingmap // <4>
----
<1> A service of type `NodePort` that serves the default routes on port `8080`.
<2> A deployment with one replica of a pod.
<3> Mount the TracingMap as a volume at `/etc/tracing`.  This is where Kubernetes will create `tracing-file.properties`.
<4> Specify the TracingMap which contains the tracing data.


[source,bash]
.Create and deploy the application into Kubernetes:
----
kubectl apply -f ./k8s-tracing.yaml
----

[source,bash]
.Get the service information:
----
kubectl get service/helidon-tracing
----

[source,bash]
----
NAME             TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
helidon-tracing   NodePort   10.99.159.2   <none>        8080:31143/TCP   8s // <1>
----
<1> A service of type `NodePort` that serves the default routes on port `31143`.

[source,bash]
.Verify the tracing endpoint using port `31143`, your port will likely be different:
----
curl http://localhost:31143/greet
...
{
  "message": "HelloFromTracingFile World!" // <1>
}
----
<1> The greeting value from `/etc/tracing/tracing-file.properties` within the container was used.


You can now delete the Kubernetes resources that were just created during this example.

[source,bash]
.Delete the Kubernetes resources:
----
kubectl delete -f ./k8s-tracing.yaml
kubectl delete tracingmap  helidon-tracingmap
----

== Summary

This guide has demonstrated how to use basic Helidon tracing features. The full tracing documentation, starting with the
introduction section at <<tracing/01_introduction.adoc, Helidon Tracing>> has much more information including
the following:

- Architecture
- Parsers
- Extensions
- Filters
- Hierarchical Access
- Property Mapping
- Mutability Support
- and more...


Refer to the following references for additional information:

- MicroProfile Tracing specification at https://github.com/eclipse/microprofile-tracing/releases/tag/1.3
- MicroProfile Tracing Javadoc at https://javadoc.io/doc/org.eclipse.microprofile.tracing/microprofile-tracing-api/1.3
- Helidon Javadoc at https://helidon.io/docs/latest/apidocs/index.html?overview-summary.html




