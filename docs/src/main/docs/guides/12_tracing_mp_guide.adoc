///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2019 Oracle and/or its affiliates. All rights reserved.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= Tracing MP Guide
:description: Helidon tracing
:keywords: helidon, tracing, microprofile, guide
:toc:

This guide describes how to create a sample MicroProfile (MP) project
that can be used to run some basic examples using tracing with Helidon MP.

== What you need

[width=50%,role="flex, sm7"]
|===
|About 30 minutes
|<<about/03_prerequisites.adoc,Helidon Prerequisites>>
|===

== Getting started with tracing

Distributed tracing is a critical feature of micro-service based applications since it traces workflow both
within a service and across multiple services.  This gives you insight to sequence and timing data for specific blocks of work,
which helps you identify performance and operational issues.  Helidon MP includes support for distributed tracing
through the https://github.com/helm/helm[OpenTracing API].  Tracing is integrated with WebServer, gRPC Server,
and Security using either the https://zipkin.io[Zipkin] or https://www.jaegertracing.io[Jaeger] tracers.
The examples in this guide will use Zipkin, and traces will be viewed using both the Zipkin API and UI.

=== Create a sample Helidon MP project

Use the Helidon MP Maven archetype to create a simple project that can be used for the examples in this guide.

[source,bash,subs="attributes+"]
.Run the Maven archetype:
----
mvn archetype:generate -DinteractiveMode=false \
    -DarchetypeGroupId=io.helidon.archetypes \
    -DarchetypeArtifactId=helidon-quickstart-mp \
    -DarchetypeVersion={helidon-version} \
    -DgroupId=io.helidon.examples \
    -DartifactId=helidon-quickstart-mp \
    -Dpackage=io.helidon.examples.quickstart.mp
----

[source,bash]
.The project will be built and run from the `helidon-quickstart-mp` directory:
----
cd helidon-quickstart-mp
----

== Spans and Traces

A _span_ is the basic unit of work done within a single service, on a single host.  Every span has a name, starting timestamp, and the duration.
A _trace_ contains a collection of spans, where spans are organzied as directed acylic graphs (DAG) and can belong to multiple services,
running on multiple hosts.  The _OpenTracing Data Model_ describes the details
at https://opentracing.io/specification[The OpenTracing Semantic Specification].
For example, when you invoke a REST API call, Helidon creates a unique `trace` to track the spans.  Then, spans are created and tracked
during execution of the REST request.  The following example demonstrates this using a simple trace.

NOTE: Helidon automatically enables tracing for JAX-RS resources methods so you don't need to use annoations with JAX-RS.

[source,bash]
Run Zipkin within a docker container.
----
.docker run -d --name zipkin -p 9411:9411 openzipkin/zipkin
----

As mentioned, Helidon include built-in support for tracing.  To enable it you need to update the pom.xml file and
add the following to the `<dependencies>` section (*not* `<dependencyManagement>`):

[source,xml]
.Add the following line to `META-INF/microprofile-tracing.properties`:
----
<dependency>
<groupId>io.helidon.tracing</groupId>
<artifactId>helidon-tracing-zipkin</artifactId>
</dependency>
----

[source,bash]
.Add the following line to `META-INF/microprofile-tracing.properties`:
----
tracing.service=helidon-mp-1
----

[source,bash]
.Build the application, skipping unit tests, then run it:
----
mvn package -DskipTests=true
java -jar target/helidon-quickstart-mp.jar
----

[source,bash]
.Run the curl command in a new terminal window and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "Hello World!"
}
----

=== Viewing tracing using Zipkin REST API

Because you have tracing enable, that endpoint invocation resulted in a new trace being created.
First, get the service that Zipkin is tracing using the Zipkin API.

[source,bash]
.Run the curl command in a new terminal window and check the response:
----
curl http://localhost:9411/api/v2/services
...
["helidon-mp-1"] // <1>
----
<1> This is the tracing service name specified in `META-INF/microprofile-tracing.properties`.

Each span used by a service has a name, which is unique within a trace. If you
invoke the `/greet` endpoint multiple times, you will still get the same set
of names.

[source,bash]
.Invoke the endpoint below and check the response:
----
curl http://localhost:9411/api/v2/spans
...
[ // <1> <span>
  "content-read",
  "content-write",
  "get:io.helidon.examples.quickstart.mp.greetresource.getdefaultmessage",
  "security",
  "security:atn",
  "security:atz",
  "security:response"
]
----
<1> These are the span names.  If you invoke the `/greet` endpoint again, then
invoke the `/spans` endpoint you will get the same response.

Finally, lets get the contents of the trace. Notice that each span has a `parentId` field,
except the `get:io.helidon.examples.quickstart.mp.greetresource.getdefaultmessage` span,
which is the root.

[source,bash]
.Invoke the endpoint below and check the response:
----
curl -X GET "http://localhost:9411/api/v2/traces?serviceName=helidon-mp-1&limit=1" -H "accept: application/json"  // <1>
...
[
  [ // <2>
    {
      "traceId": "2e0af8866efdef35",
      "parentId": "2e0af8866efdef35",
      "id": "b5d61690f230fde4",
      "kind": "SERVER",
      "name": "content-read",
      "timestamp": 1568077339998659,
      "duration": 41,
      "localEndpoint": {
        "serviceName": "helidon-mp-1",
        "ipv4": "192.168.1.115"
      },
      "tags": {
        "requested.type": "java.io.InputStream" // <3>
      }
    },
...
(truncated)
]

----
<1> Get the oldest trace only, using the `limit=1` query param.  There are other query params that lets you restrict
results to a specific time window.
<2> The request will return seven spans, one for each name, along with an unamed JSON node, which
has the status.
<3> User defined tags can be used to query, filter, and understand trace data.

=== Viewing tracing using Zipkin UI

Even with a tracing trivial example, the tracing output data is verbose and can be difficult to interpret using the REST API.  Zipkin
offers a web-based UI at http://localhost:9411/zipkin, where you can see a visual representation of the same data and the
relationship between spans within a trace, and even across services.

The image below view shows trace summary, including start time and duration.  There are two traces,
each one generated in response to a `curl http://localhost:8080/greet` invocation.

image::guides/12_tracing_top.png[Traces]

Click on trace `2e0af8866efdef35` and you will see the trace detail page where the spans are listed.  You can clearly
see the root span and the relationship among all the spans in the trace, along with timing information.

image::guides/12_tracing_detail.png[Trace Detail]

NOTE: A parent span might not depend on the result of the child. This is called a `FollowsFrom` reference, see
https://github.com/opentracing/specification/blob/master/specification.md[Open Tracing Semantic Spec].  Notice, the
last span which writes the response after the root span ends, falls into this category.

=== Enabling Tracing on CDI beans

So far, you have used tracing with JAX-RS without needing to annotate.  You can enable tracing on other CDI beans, either at the class level
or at the method level, as shown by the following example.

==== Tracing at the method level

To trace at the mthod level, you just annotate a method with @Traced.

[source,java]
.Add the @Traced annoation to the `GreetingProvider.getMessage':
----
    @Traced  // <1>
    String getMessage() {
        return message.get();
    }
...
----
<1> This will enable tracing for getMessage

[source,bash]
.Build and run the application, then invoke the endpoints and check the response:
----
curl http://localhost:8080/greet
curl -X GET "http://localhost:9411/api/v2/spans?serviceName=helidon-mp-1" -H "accept: application/json" // <1>
...
[
  "content-read",
  "content-write",
  "dosomework",
  "get:io.helidon.examples.quickstart.mp.greetresource.getdefaultmessage",
  "io.helidon.examples.quickstart.mp.greetingprovider.getmessage", // <2>
  "security",
  "security:atn",
  "security:atz",
  "security:response"
]
----
<1> Get the span names.
<2> There is new span name for the `getmessage` method, since your code called that method during the
invocation of `/greet`.


Click on the UI refresh button (the search icon) as shown in the image below.

image::guides/12_tracing_refresh.png[Trace Refresh]


Click on the first trace in the list to see the trace detail page.  Notice the new span named `io.helidon.examples.quickstart.mp.greetingprovider.getmessage`.

image::guides/12_tracing_getmessage.png[Trace getmessage]

You can examine span details by clicking on the span row.  Refer to the image below.  This view shows detailed timing information along with tags.  You can see
that the security span started execution `-19259Î¼s` before the `getDefaultMessage` root span started.  The security span, and its children
finished execution at `25.452ms` after the  `getDefaultMessage` span started.

image::guides/12_tracing_span_detail.png[Span Details]


==== Tracing at the class level

To trace at the class level, annotate the class with @Traced. This will enable tracing for all class methods,
except for the constructor along with methods that are private. You can remove the @Traced from the method.

[source,java]
.Add the @Traced annotation to the `GreetingProvider` class.
----
@Traced // <1>
@ApplicationScoped
public class GreetingProvider {
...
----
<1> This will enable tracing for all class methods except for the constructor and methods that are private.

[source,bash]
.Build and run the application, then invoke the endpoints and check the response:
----
curl http://localhost:8080/greet
curl -X GET "http://localhost:9411/api/v2/spans?serviceName=helidon-mp-1" -H "accept: application/json"
[
...
  "io.helidon.examples.quickstart.mp.greetingprovider.getmessage", // <1>
...
]
----
<1> The same set of span names as above, since `getmessage` was the only method called in this bean.

Lets call the other method, 'setMessage', but invoking HTTP PUT to change the greeting.

[source,bash]
.Build and run the application, then invoke the endpoints and check the response:
----
curl -i -X PUT -H "Content-Type: application/json" -d '{"greeting": "Hi"}'  http://localhost:8080/greet/greeting // <1>
curl -X GET "http://localhost:9411/api/v2/spans?serviceName=helidon-mp-1" -H "accept: application/json"
...
[
  "content-read",
  "content-write",
  "get:io.helidon.examples.quickstart.mp.greetresource.getdefaultmessage",
  "io.helidon.examples.quickstart.mp.greetingprovider.getmessage",
  "io.helidon.examples.quickstart.mp.greetingprovider.setmessage", // <2>
  "put:io.helidon.examples.quickstart.mp.greetresource.updategreeting", // <3>
  "security",
  "security:atn",
  "security:atz",
  "security:response"
]
----
<1> Invoke the endpoint to change the greeting.
<2> The `GreetingProvider.setmessage` method was traced since you enabled class level tracing.
<3> The JAX-RS method 'GreetResource.updategreeting' was traced automatically by Helidon.

You can refersh the UI view and drill down the trace to see the new spans.

=== Tracing across services

Helidon automatically traces across services, providing that the services use the same tracer, for example: the same instance of Zipkin.
This means a single trace can include spans from multiple services and hosts.  Likewise, a span can have descendents from different
services and hosts.  As mentioned previously, a span itself is restricted to a single service.  OpenTracing uses a `SpanContext` to
propagate tracing information across process bounderies.  When you make client API calls that cross process boundaries, Helidon will
internally call OpenTracing APIs to propagate the `SpanContext`. There is nothing you need to do in your application to make this work.

== Integration with Kubernetes

The following example uses a Kubernetes TracingMap to pass the tracing data to your Helidon application deployed to Kubernetes.
When the pod is created, Kubernetes will automatically create a local file within the container that has the contents of the
tracing file that is used for the TracingMap.  This example will create the file at `/etc/tracing/tracing-file.properties`.

[source,java]
.Update the `Main` class and replace the 'buildTracing` method:
----
  private static Tracing buildTracing() {
      return Tracing.builder()
          .sources(
              file("/etc/tracing/tracing-file.properties").optional(), // <1>
              classpath("META-INF/microprofile-tracing.properties")) // <2>
          .build();
  }
----
<1> The `app.greeting` value will be fetched from `/etc/tracing/tracing-file.properties` within the container.
<2> The server port is specified in `META-INF/microprofile-tracing.properties` within the `helidon-quickstart-mp.jar`.

[source,java]
.Update the following code from `GreetingProvider.java`:
----
@ApplicationScoped
public class GreetingProvider {

    @Inject
    @TracingProperty(name = "app.greeting") // <1>
    private volatile String message; // <2>

    String getMessage() {
        return message;
    }

    void setMessage(String message) {
        this.message = message;
    }
}
----

[source,bash]
.Build and run the application, then invoke the endpoint and check the response:
----
curl http://localhost:8080/greet
...
{
  "message": "HelloFromTracingFile World!"
}
----

[source,bash]
.Stop the application and build the docker image:
----
docker build -t helidon-tracing-mp .
----

[source,bash]
.Generate a TracingMap from `tracing-file.properties`:
----
kubectl create tracingmap helidon-tracingmap --from-file tracing-file.properties
----

[source,bash]
.View the contents of the TracingMap:
----
kubectl get tracingmap helidon-tracingmap -o yaml
...
apiVersion: v1
data:
  tracing-file.properties: |   // <1>
    app.greeting=HelloFromTracingFile   // <2>
kind: TracingMap
...
----
<1> The file `tracing-file.properties` will be created within the Kubernetes container.
<2> The `tracing-file.properties` file will have this single property defined.


[source,yaml]
.Create the Kubernetes YAML specification, named `k8s-tracing.yaml`, with the following contents:
----
kind: Service
apiVersion: v1
metadata:
  name: helidon-tracing // <1>
  labels:
    app: helidon-tracing
spec:
  type: NodePort
  selector:
    app: helidon-tracing
  ports:
    - port: 8080
      targetPort: 8080
      name: http
---
kind: Deployment
apiVersion: extensions/v1beta1
metadata:
  name: helidon-tracing
spec:
  replicas: 1 // <2>
  template:
    metadata:
      labels:
        app: helidon-tracing
        version: v1
    spec:
      containers:
        - name: helidon-tracing
          image: helidon-tracing-mp
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
          volumeMounts:
            - name: tracing-volume
              mountPath: /etc/tracing // <3>
      volumes:
        - name: tracing-volume
          tracingMap:
            # Provide the name of the TracingMap containing the files you want
            # to add to the container
            name:  helidon-tracingmap // <4>
----
<1> A service of type `NodePort` that serves the default routes on port `8080`.
<2> A deployment with one replica of a pod.
<3> Mount the TracingMap as a volume at `/etc/tracing`.  This is where Kubernetes will create `tracing-file.properties`.
<4> Specify the TracingMap which contains the tracing data.


[source,bash]
.Create and deploy the application into Kubernetes:
----
kubectl apply -f ./k8s-tracing.yaml
----

[source,bash]
.Get the service information:
----
kubectl get service/helidon-tracing
----

[source,bash]
----
NAME             TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
helidon-tracing   NodePort   10.99.159.2   <none>        8080:31143/TCP   8s // <1>
----
<1> A service of type `NodePort` that serves the default routes on port `31143`.

[source,bash]
.Verify the tracing endpoint using port `31143`, your port will likely be different:
----
curl http://localhost:31143/greet
...
{
  "message": "HelloFromTracingFile World!" // <1>
}
----
<1> The greeting value from `/etc/tracing/tracing-file.properties` within the container was used.


You can now delete the Kubernetes resources that were just created during this example.

[source,bash]
.Delete the Kubernetes resources:
----
kubectl delete -f ./k8s-tracing.yaml
kubectl delete tracingmap  helidon-tracingmap
----

== Summary

This guide has demonstrated how to use basic Helidon tracing features. The full tracing documentation, starting with the
introduction section at <<tracing/01_introduction.adoc, Helidon Tracing>> has much more information including
the following:

- Architecture
- Parsers
- Extensions
- Filters
- Hierarchical Access
- Property Mapping
- Mutability Support
- and more...


Refer to the following references for additional information:

- MicroProfile Tracing specification at https://github.com/eclipse/microprofile-tracing/releases/tag/1.3
- MicroProfile Tracing Javadoc at https://javadoc.io/doc/org.eclipse.microprofile.tracing/microprofile-tracing-api/1.3
- Helidon Javadoc at https://helidon.io/docs/latest/apidocs/index.html?overview-summary.html




