///////////////////////////////////////////////////////////////////////////////

    Copyright (c) 2019 Oracle and/or its affiliates. All rights reserved.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

///////////////////////////////////////////////////////////////////////////////

= Configuration MP Guide
:description: Helidon configuration
:keywords: helidon, configuration, microprofile, guide

This guide describes how to create a sample MicroProfile (MP) project
that can be used to run some basic examples using both built-in and custom configuration with Helidon MP.

== What you need

[width=50%,role="flex, sm7"]
|===
|About 30 minutes
|<<about/03_prerequisites.adoc,Helidon Prerequisites>>
|===

=== Create a sample Helidon MP project

Use the Helidon MP Maven archetype to create a simple project that can be used for the examples in this guide.

[source,bash,subs="attributes+"]
.Run the Maven archetype:
----
mvn archetype:generate -DinteractiveMode=false \
    -DarchetypeGroupId=io.helidon.archetypes \
    -DarchetypeArtifactId=helidon-quickstart-mp \
    -DarchetypeVersion={helidon-version} \
    -DgroupId=io.helidon.examples \
    -DartifactId=helidon-quickstart-mp \
    -Dpackage=io.helidon.examples.quickstart.mp
----

=== Configuration sources

You can configure Helidon to read configuration data from a variety of sources, and in several formats.  Helidon
will parse and merge all sources into an in-memory tree which represents the configurationâ€™s structure and values.
By default, Helidon will load the configuration specified in `META-INF/microprofile-config.properties`,
which defines properties using Java Property format (name/value pair).  If `META-INF/microprofile-config.properties`
is missing then Helidon will use a set of default configuration values.

=== Classpath sources

The following example demonstrates how to add a second internal configuration resource that is discovered in the `classpath`.
The code needs to build a `Config` object, which in turn is used to build the `Server` object.  The `Config` object is built using a `Config.Builder`,
which lets you inject any number of sources into the builder.  Furthermore, you can set precedence for the sources.
The first source has highest precedence, then the next has second highest, and so forth.  This is true for all sources, regardless of the type.

Let's verify the default behavior of the project that you generated:

[source,bash]
.Build the application, skipping unit tests, then run it:
----
mvn package -DskipTests=true
java -jar target/helidon-quickstart-mp.jar
----

[source,bash]
.Verify the configuration endpoint in a new terminal window:
----
curl http://localhost:8080/greet
----

[source,json]
.JSON response:
----
{
  "message": "Hello World!"
}
----

Add a second resource file, named `config.properties` to the `resources` folder with the following content:

[source,text]
.`resources/config.properties`
----
app.greeting=Hi
----

[source,java]
.Update the `Main` class; 1) Add imports, 2) replace the `startServer` method, 3) add the `buildConfig` method:
----
import io.helidon.config.Config;
import static io.helidon.config.ConfigSources.classpath;
...

    static Server startServer() {
        return Server.builder()
                .config(buildConfig()) // <1>
                .build()
                .start();
    }

    private static Config buildConfig() {
        return Config.builder()
            .sources(
                classpath("config.properties"), // <2>
                classpath("META-INF/microprofile-config.properties")) // <3>
            .build();
    }

----
<1> Inject the custom `Config` object into the `Server.Builder`.
<2> Specify the new config.properties resource that is in the `classpath`.  It has the highest precedence of any source.
<3> Specify the existing `META-INF/microprofile-config.properties` that is also in the `classpath` (see note below).

NOTE: When you use a custom `Config` object, you are responsible for specifying all resources,
even the default `META-INF/microprofile-config.properties` resource.


[source,bash]
.Build and run the application, then invoke the endpoint below:
----
curl http://localhost:8080/greet
----

[source,json]
.JSON response:
----
{
  "message": "Hi World!" // <1>
}
----
<1> The greeting was picked up from `config.properties`, overriding the value in `META-INF/microprofile-config.properties`.

NOTE: It is important to remember that configuration from all sources get merged internally.  If you have the same
 configuration property in multiple sources then only the one with highest precedence will be used at runtime.
This is true even the same property comes from sources with different formats.

=== External file sources

You can use an external file as a configuration source and mark it as optional.  By default, any specified external source is mandatory
and it if is missing, Helidon will not start.  The following example will demonstrate this.

[source,java]
.Replace the `Main.buildConfig` method with the following:
----
    private static Config buildConfig() {
        return Config.builder()
            .sources(
                file("missing"),  // <1>
                classpath("config.properties"),
                classpath("META-INF/microprofile-config.properties"))
            .build();
    }
----
<1> Specifiy a file configuration source that doesn't exist.


[source,bash]
.Build and run the application.  You should see the following exception:
----
Exception in thread "main" io.helidon.config.ConfigException: Cannot load data from mandatory source FileConfig[missing]. File 'missing' not found.
----

This can be fixed by making the file optional.

[source,java]
.Replace the `Main.buildConfig` method with the following:
----
    private static Config buildConfig() {
        return Config.builder()
            .sources(
                file("missing").optional(), // <1>
                classpath("config.properties"),
                classpath("META-INF/microprofile-config.properties"))
            .build();
    }
----
<1> This file is now optional.

[source,bash]
.Build and run the application, then invoke the endpoint below:
----
curl http://localhost:8080/greet
----

[source,json]
.JSON response:
----
{
  "message": "Hi World!" // <1>
}
----
<1> The greeting was picked up from `config.properties` since the source file `missing` was not found.

=== Configuration Formats


=== Accessing Configuration within an application


=== Integration with Kubernetes

The following example shows how to integrate the Helidon MP application with Kubernetes.

[source,bash]
.Stop the application and build the docker image:
----
docker build -t helidon-configuration-mp .
----

[source,yaml]
.Create the Kubernetes YAML specification, named `config.yaml`, with the following content:
----
kind: Service
apiVersion: v1
metadata:
  name: helidon-configuration // <1>
  labels:
    app: helidon-configuration
  annotations:
    prometheus.io/scrape: 'true' // <2>
spec:
  type: NodePort
  selector:
    app: helidon-configuration
  ports:
    - port: 8080
      targetPort: 8080
      name: http
---
kind: Deployment
apiVersion: extensions/v1beta1
metadata:
  name: helidon-configuration
spec:
  replicas: 1 // <3>
  template:
    metadata:
      labels:
        app: helidon-configuration
        version: v1
    spec:
      containers:
        - name: helidon-configuration
          image: helidon-configuration-mp
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
----
<1> A service of type `NodePort` that serves the default routes on port `8080`.
<2> An annotation that will allow Prometheus to discover and scrape the application pod.
<3> A deployment with one replica of a pod.


[source,bash]
.Create and deploy the application into Kubernetes:
----
kubectl apply -f ./config.yaml
----

[source,bash]
.Get the service information:
----
kubectl get service/helidon-configuration
----

[source,bash]
----
NAME             TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
helidon-configuration   NodePort   10.99.159.2   <none>        8080:31143/TCP   8s // <1>
----
<1> A service of type `NodePort` that serves the default routes on port `31143`.

[source,bash]
.Verify the configuration endpoint using port `30116`, your port will likely be different:
----
curl http://localhost:31143/configuration
----

You can now delete the Kubernetes resources that were just created during this example.

[source,bash]
.Delete the application Kubernetes resources:
----
kubectl delete -f ./config.yaml
----

=== Summary

This guide demonstrated how to use configuration in a Helidon MP application using various combinations of
sources and formats:

* A

Refer to the following references for additional information:

* <<about/01_introduction.adoc,Helidon Configuration>>
* Helidon Javadoc at https://helidon.io/docs/latest/apidocs/index.html?overview-summary.html

